!<DOCTYPE html>
<html>
  <head>
    <title>FP 101</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <style type="text/css">
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 {
          font-family: 'Yanone Kaffeesatz';
          font-weight: normal;
        }
        .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Functional Programming 101

Elliot Stern

---
# First-class functions

- "First class" means that it's something the language can manipulate, just like any other "normal" value
- For example: the ability to store in a variable, to take as a function parameter, or use as a functions return value.
- So: first class functions can be returned from functions, or taken as arguments

---

# Map
```javascript

// given an Array<A>, array.map(f : A => B) : Array[B]
// [x,y,z].map(f) evaluates to [f(x), f(y), f(z)]

function square(x){
  return x * x;
}

[1,2,3,4,5].map(square);
// returns [1,4,6,8,25]
```
---
# Anonymous functions

- Instead of defining a named function, in some languages you can define a function inline.

```javascript
[1,2,3,4,5].map(function(x) { return x * x });

// New syntax added to Javascript standard in 2015

[user1, user2, user3].map( user => user.userName);
// returns ["estern", "ryansb", "lois"]
```

---

# Reduce
```javascript
// applies a binary function to each element of a list, starting from the left
// given an Array<A>, array.reduce(f: (B, A) => A, initial: B): B
// [x, y, z].reduce(f, initial) == f(f(f(initial, x), y), z)

[1,2,3,4,5].reduce((accumulator, current) => current + accumulator, 0)
// turns into ((((0 + 1) + 2) + 3) + 4) + 5 = 15
```
---
# FlatMap
```javascript
// list.flatMap(f) == list.map(x).flat()
// given an Array[A], array.flatMap(f : A => Array[B]) : Array[B]

[1,2,3].flatMap(x => [x, 2 * x, 3 * x])
// [1,2,3,2,4,6,3,6,9]

var range = [1,2,3,4,5,6,7,8,9,10]

range.flatMap(a =>
  range.flatMap(b =>
    range.flatMap( c =>
      if(a^2 + b^2 == c^2) {
        return [(a, b, c)]
      } else {
        return []
      })))

```
---

``` javascript
class Ordering {
  // compare is a function that takes x and y
  // and returns 0 if they're the same
  // a positive number if x is greater than y
  // a negative number if x is less than y
  // constructor(compare: (A, A) => number) : Ordering[A]
  constructor(compare) {
    this.compare = compare;
  }

  invert() {
    return new Ordering( (x, y) => -this.compare(x, y));
  }

  // contramap(f: B => A): Ordering[B]
  contramap(f) {
    return new Ordering( (x, y) => this.compare(f(x), f(y)));
  }

}

// intOrdering : Ordering[number]
var intOrdering = new Ordering((x, y) => x - y);
// lengthOrdering : forall A.  Ordering[Array[A]]
var lengthOrdering = intOrdering.contramap(x => x.length);

[[1], [2,3,4], [2,3]].sort(lengthOrdering.compare)
// lengthOrdering.contramap(c => c.inventory) : Ordering[Character]
charactersList.sort(lengthOrdering.contramap(c => c.inventory))
```

---
# Free Variables

- A variable which doesn't appear inside a function definition is a "free" variable


```javascript
// y is "free" in the context of this function
var addY = x => x + y
```

---

# Closures
"Closes over" an environment, storing references to variables currently in scope

```javascript
function derive(f) {
    var h = 0.000001;
    // f is free in the context of the function we return
    // so this returns a closure with a reference to the f that was passed in
    return x => (f(x+h) - f(x)) / h;
}

var slopeOfXSquared = derive(x => x * x);
slopeOfXSquared(1); // 2.0000009999243673
slopeOfXSquared(2); // 4.0000010006480125

var slopeOf2X = derive(x => 2 * x);
slopeOf2x(1) // 1.9999999998354667
slopeOf2x(2) // 2.000000000279556

```
---

# A koan about objects and closures

  The venerable master Qc Na was walking with his student, Anton.  Hoping to
prompt the master into a discussion, Anton said "Master, I have heard that
objects are a very good thing - is this true?"  Qc Na looked pityingly at
his student and replied, "Foolish pupil - objects are merely a poor man's
closures."

  Chastised, Anton took his leave from his master and returned to his cell,
intent on studying closures.  He carefully read the entire "Lambda: The
Ultimate..." series of papers and its cousins, and implemented a small
Scheme interpreter with a closure-based object system.  He learned much, and
looked forward to informing his master of his progress.

  On his next walk with Qc Na, Anton attempted to impress his master by
saying "Master, I have diligently studied the matter, and now understand
that objects are truly a poor man's closures."  Qc Na responded by hitting
Anton with his stick, saying "When will you learn? Closures are a poor man's
object."  At that moment, Anton became enlightened.


---
# Closures as a poor man's object
```javascript
// Javascript object
function Average(total, count) {
    this.total = total;
    this.count = count;
    this.val = total / count;
    this.add = other => new Average(total + other.total, count + other.count);
}
var zeroAverage = new Average(0, 0)
function toAverage(x) {
    return new Average(x, 1);
}
// closure as object
function average2(total, count) {
  return function(selector, ...args) { // ..args means this takes a variable number of arguments
    switch (selector) {
        case "total": return total;
        case "count": return count;
        case "val": return total / count;
        case "add":
            var other = args[0];
            return average2(total + other("total"), count + other("count"));
        default: return undefined;
    }
  }
}

var zeroAverage2 = average2(0, 0);
function toAverage2(x) {
    return average2(x, 1);
}
```
---
# Reduce, continued
```javascript
[1,2,3,4,5]
  .map(toAverage)
  .reduce((accumulator, current) => current.add(accumulator), zeroAverage).val
  // 3

```

      </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>


